<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Accept-Auth HTTP Header for 3xx/401 Negotiation, and Redirect Authentication Scheme</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.2" rel="Chapter" title="2 Accept-Redirect and       Accept-Redirect-Auth">
<link href="#rfc.section.3" rel="Chapter" title="3 Accept-Auth">
<link href="#rfc.section.4" rel="Chapter" title="4 The Redirect Authentication Scheme">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Redirect Examples">
<link href="#rfc.section.5" rel="Chapter" title="5 Applicability">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Applicability of Accept-* Headers">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Applicability of Redirect Auth Scheme">
<link href="#rfc.section.6" rel="Chapter" title="6 Mixing Redirection and Authentication Requests">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 3xx Responses with WWW-Authenticate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 401 Responses with Location">
<link href="#rfc.section.7" rel="Chapter" title="7 Auth-params for Selected Authentication Mechanisms">
<link href="#rfc.section.8" rel="Chapter" title="8 Server-Side Selection of Authentication Schemes">
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgements">
<link href="#rfc.section.10" rel="Chapter" title="10 IANA Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Multi-Level Negotiation">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Williams, N., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-williams-http-accept-auth-and-redirect-02" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-02" />
  <meta name="dct.abstract" content="The Hyper-Text Transport Protocol (HTTP) offers several authentication schemes, but many sites use redirection-based protocols to authenticate users.  Some servers are faced with a connundrum, having to choose between two mutually-exclusive options: redirect responses or 401 (authentication required) responses without knowing which the user-agent is most likely to support.  " />
  <meta name="description" content="The Hyper-Text Transport Protocol (HTTP) offers several authentication schemes, but many sites use redirection-based protocols to authenticate users.  Some servers are faced with a connundrum, having to choose between two mutually-exclusive options: redirect responses or 401 (authentication required) responses without knowing which the user-agent is most likely to support.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">N. Williams, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cryptonector, LLC</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">April 2, 2020</td>
</tr>
<tr>
<td class="left">Expires: October 4, 2020</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Accept-Auth HTTP Header for 3xx/401 Negotiation, and Redirect Authentication Scheme<br />
  <span class="filename">draft-williams-http-accept-auth-and-redirect-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Hyper-Text Transport Protocol (HTTP) offers several authentication schemes, but many sites use redirection-based protocols to authenticate users.  Some servers are faced with a connundrum, having to choose between two mutually-exclusive options: redirect responses or 401 (authentication required) responses without knowing which the user-agent is most likely to support.  </p>
<p>This document specifies new HTTP request headers by which many applications can improve interoperability even without changing their HTTP implementations.  These new headers allow user-agents to advertise authentication- and redirect-related capbilities that servers can use to better make authentication and/or redirect decisions.  </p>
<p>Also specified is a new HTTP authentication scheme named "Redirect" that enables communication between redirecting and redirected authorities via preservation of "Authorization" and "Authorization-Request" headers across redirections.  This enables arbitrary authentication and authorization protocols to work without requiring user-agent support for them and without having to (ab)use URI query parameters.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 4, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Accept-Redirect and       Accept-Redirect-Auth</a>
</li>
<li>3.   <a href="#rfc.section.3">Accept-Auth</a>
</li>
<li>4.   <a href="#rfc.section.4">The Redirect Authentication Scheme</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Redirect Examples</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Applicability</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Applicability of Accept-* Headers</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Applicability of Redirect Auth Scheme</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Mixing Redirection and Authentication Requests</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">3xx Responses with WWW-Authenticate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">401 Responses with Location</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Auth-params for Selected Authentication Mechanisms</a>
</li>
<li>8.   <a href="#rfc.section.8">Server-Side Selection of Authentication Schemes</a>
</li>
<li>9.   <a href="#rfc.section.9">Acknowledgements</a>
</li>
<li>10.   <a href="#rfc.section.10">IANA Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Security Considerations</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Multi-Level Negotiation</a>
</li>
</ul><li>12.   <a href="#rfc.references">References</a>
</li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The Hyper-Text Transport Protocol (HTTP) <a href="#RFC7230" class="xref">RFC7230</a> provides several schemes for user authentication.  There also are popular ways of authenticating users based on redirection rather than standard HTTP authentication schemes.  Heretofore, HTTP has provided no standard way for servers to know which authentication schemes, including redirect-based methods, a given user-agent supports, but servers must choose between either redirection or HTTP authentication, and these two are mutually exclusive.  </p>
<p id="rfc.section.1.p.2">This situation arises especially in corporate networks where JSON Web Tokens (JWT) <a href="#RFC7519" class="xref">[RFC7519]</a> and Negotiate <a href="#RFC4559" class="xref">[RFC4559]</a> are both used, the latter usually with the Kerberos <a href="#RFC4120" class="xref">[RFC4120]</a> GSS-API <a href="#RFC2743" class="xref">[RFC2743]</a> mechanism <a href="#RFC4121" class="xref">[RFC4121]</a>.  </p>
<p id="rfc.section.1.p.3">We address this problem by adding new request headers, "Accept-Auth:", "Accept-Redirect-Auth:", and "Accept-Redirect:" by which a user-agent can indicate which HTTP authentication schemes, if any, it supports, including redirection.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#accept_redirect" id="accept_redirect">Accept-Redirect and       Accept-Redirect-Auth</a>
</h1>
<p id="rfc.section.2.p.1">The Accept-Redirect request header has two possible values: "yes" and "no".  If "yes", this means the user-agent will follow redirections, and the user-agent may or may not be willing to authenticate at the redirected origin depending on local policy.  </p>
<p id="rfc.section.2.p.2">The Accept-Redirect-Auth request header exists to indicate which authorities the user-agent is willing to redirect to and authenticate at.  Its value is a whitespace-separate list of domainnames.  If empty or has just the value ".", then the service can conclude only that the user-agent has a whitelist, but is not disclosing it.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#accept_auth" id="accept_auth">Accept-Auth</a>
</h1>
<p id="rfc.section.3.p.1">The Accept-Auth request header may have multiple values, or be present multiple times, as with most HTTP headers.  Each value names one authentication schemes, and optionally may indicate schemes-specific metadata.  </p>
<p id="rfc.section.3.p.2">Accept-Auth values are similar to WWW-Authenticate values <a href="#RFC7235" class="xref">[RFC7235]</a>, but they do not have quite the same form, and they are not challenges.  Using ABNF <a href="#RFC5234" class="xref">[RFC5234]</a>: </p>
<div id="rfc.figure.1"></div>
<div id="accept_auth_abnf"></div>
<p></p>
<pre>
; Can we use the RFC7230 #rule ABNF extension here?
Accept-Auth-values = Accept-Auth-value *( OWS ","
                                          OWS Accept-Auth-value )
Accept-Auth-value = auth-scheme [1*SP
                                 ( auth-param *( "+" auth-param ) ]
auth-scheme = token
auth-param = token BWS "=" BWS ( token / quoted-string )
token          = 1*tchar
tchar          = "!" / "'" / "*" / "-" / "." / "^"
               / "_" / "`" / "|" / "~" / DIGIT / ALPHA
               ; any VCHAR, except delimiters; here we use "+"
               ; as a delimiter, so our token definition is
               ; different from RFC7230's.

BWS = &lt;BWS, see [RFC7230], Section 3.2.3&gt;
OWS = &lt;OWS, see [RFC7230], Section 3.2.3&gt;
quoted-string = &lt;quoted-string, see [RFC7230], Section 3.2.6&gt;
            </pre>
<p>Accept-Auth value ABNF.</p>
<p class="figure">Figure 1</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#redirect" id="redirect">The Redirect Authentication Scheme</a>
</h1>
<p id="rfc.section.4.p.1">Many sites use redirect-based protocols for authentication.  Such protocols exchange cryptographic messages between a relying party origin and an authenticator origin.  Some such protocols use URI query parameters to carry cryptographic messages.  Others depend on the browser HTML and ECMAScript ecosystem, using a script to run HTTP requests from the authenticator to the relying party with a token in Authorization request header.  In the latter case, the server exchanges the token for a cookie, and a script on the authenticator page then effects a redirect by changing the window location.  </p>
<p id="rfc.section.4.p.2">Such redirect-based protocols do not work for non-browser user-agents.  </p>
<p><a id="COMMENT_CB0" class="info">[COMMENT_CB0]<span class="info">NW: It might be good to also specify request headers for redirected requests that user-agents can use for passing channel binding information to auth services.  E.g., Redirect-Channel-Binding: &lt;type&gt; &lt;cb-data&gt;.  This would allow Authorization tokens to be channel-bound.  Of course, there are difficulties here that would require additional thinking.  For example, using unique CB would require that the user-agent keep a connection open to the redirecting origin.  While end-point CB would fail if multiple servers serve the same origin using different server certificates for the same names.  Binding to the dNSName and the issuer, however, would work, but that would be a new CB type and would require registration in the IANA CB type registry.  CB support could always be added later.  </span></a> </p>
<p id="rfc.section.4.p.4">User-agents normally do not copy response headers from redirect responses redirected requests.  One common non-browser user-agent, the <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7">PowerShell command-line user-agent</a>, has an option, <samp>-PreserveAuthorizationOnRedirect</samp> that causes it to copy Authorization headers from redirect responses to redirected requests.  This enables some redirect-based workflows to work even though that user-agent is not a browser, lacks interaction capabilities, HTML rendering, or JavaScript support.  </p>
<p id="rfc.section.4.p.5">Here we define the "Redirect" HTTP authentication scheme.  This scheme lets arbitrary authentication (and authorization) protocols exchange cryptographic messages between the relying party origin and the authenticator origin over headers rather than URI parameters.  This is done by preserving a new header, "Authorization-Request" across redirects, and the existing "Authorization" header across redirects back to previous origins in the redirect chain.  </p>
<p id="rfc.section.4.p.6">For our purposes, a "redirect response" is either a 3xx redirect response with a Location header, or a 401 response with a WWW-Authenticate header naming the Redirect authentication scheme and a Location header.  </p>
<p></p>

<ul>
<li>User-agents that support the Redirect HTTP authentication scheme MUST recognize a 401 Redirect challenge as a redirect response.  <ul class="empty">
<li><a id="COMMENT_0" class="info">[COMMENT_0]<span class="info">NW: QUESTION: What, if anything, should we say about the method used by the user-agent when chasing a redirection? </span></a></li>
<li><a id="COMMENT_1" class="info">[COMMENT_1]<span class="info">NW: One possibility is to let the redirecting origin specify the method and state some constraints (e.g., if the original method cannot have a request body, then the next method must be GET, else ???).  </span></a></li>
<li><a id="COMMENT_2" class="info">[COMMENT_2]<span class="info">NW: Since the intent is to authenticate the user, a GET should always be good enough.  In particular, the authenticator origin may not need to see the original request body at all, though it may need to know the original method, and it can get that from the relying party (e.g., via the Redirect header preservation mechanism).  </span></a></li>
</ul>
<p> </p>
</li>
<li>User-agents SHOULD also consider challenges for other authentication schemes offered by the server.  E.g., if the server offers a Negotiate <a href="#RFC4559" class="xref">[RFC4559]</a> challenge and a Redirect challenge, the user-agent may choose either (or neither) of the two.  </li>
<li>User-agents that support the Redirect HTTP authentication scheme MUST copy any Authorization-Request headers in redirect responses to the redirected request.  </li>
<li>User-agents that support the Redirect HTTP authentication scheme MUST copy any Authorization headers in redirect responses to the redirected request when the redirect is to an origin seen earlier in the same redirect chain.  </li>
<li>Servers needing to authenticate the user when the user-agent has advertised support for the Redirect authentication scheme SHOULD respond with a 401 with a "challenge" for the Redirect authentication scheme and a Location header, and MAY include an Authorization-Request header in the response that the user-agent then MUST copy to the redirected request if it chooses to follow the redirection.  </li>
<li>Servers that have been redirected to MUST apply local policy to decide: <ul>
<li>whether to accept redirections from the redirecting origin;</li>
<li>whether to further redirect the request (as usual) and whether to set an Authorization-Request header in the redirect response; </li>
<li>whether to authenticate the user (as usual);</li>
<li>whether to redirect back to the redirecting origin, and whether to set an Authorization header in the redirect response.  </li>
</ul>
<p> </p>
</li>
<li>User-agents may consult the user (if interactive), and/or a local policy (e.g., a white-list of acceptable origins for redirections), in order to decide whether to follow the redirection.  </li>
<li>Note that the redirected-to service should always have enough information to decide whether to accept or reject a redirection (e.g., via the Referer header), and MUST have and apply local policy of its own.  </li>
</ul>

<p> </p>
<p id="rfc.section.4.p.8">Note that nothing in this document alters or obviates Cross-Origin Resource Sharing policy and considerations.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#redirect_examples" id="redirect_examples">Redirect Examples</a>
</h1>
<p id="rfc.section.4.1.p.1">Consider a URL https://janedoe.catvidhub.com.example/v0.mpg which redirects to https://janedoe.catvidhub.io.example/v0.mpg, and suppose the latter also wants to authenticate users via redirection to an authenticator at https://auth.catvidhub.nu.example/.  Let us label these A, B, and C respectively.  </p>
<p id="rfc.section.4.1.p.2">In this example we should see a normal redirect from A to B, and at B we should see a redirect to C, and then finally a redirect back from C to B, and then B should serve the desired resource ("/v0.mpg") if C provided the user-agent with a suitable token.  Using the Redirect auth scheme we should see: </p>

<ul>
<li>Server A would respond with a normal 3xx redirect to B, not a 401 authenticate-with-Redirect, and no Authorization or Authorization-Request headers in the redirect response.  </li>
<li>Server B would respond with a 401 authenticate-with-Redirect response, no Authorization headers in its response, and (probably) a Authorization-Request header in the response by which it might send a signed request for authorization to the "/v0.mpg" resource.  </li>
<li>Server C would check cookies and possibly respond with a 401 for the user-agent to authenticate using some other scheme.  </li>
<li>Once the user is authenticated, server C would check the user's authorization to access the resource ("/v0.mpg"), and if permitted, would respond with a 3xx response with an Authorization header bearing a cryptographic token for B attesting to the user's authorization.  </li>
<li>Since server C's redirection doubles back to a server (B) seen earlier in the redirect chain, the user-agent would preserve the Authorization header from the response, which means server B would see it, verify its integrity, decode it, and then serve the resource.  </li>
</ul>

<p> </p>
<p><a id="CREF5" class="info">[CREF5]<span class="info">NW: Ah, but if server C wants to respond with HTML and ECMAScript for a browser to evaluate as an aid to authentication, what status code shall it use for that?  If a 2xx, then the redirect chain will be broken, and the Authorization header in the final redirect will not be preserved!  We could relax the rules for when to preserve the Authorization header.  Or we could not reuse the Authorization header for this, instead introducing Authorization-Response, say, with Authorization-{Request, Response} always preserved on redirects.  </span></a></p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#applicability" id="applicability">Applicability</a>
</h1>
<p id="rfc.section.5.p.1">Two different and only somewhat related features are specified here.  One is intended to help interoperability in heterogeneous environments with minimal or no changes to existing HTTP implementations, just changes to applications.  The other is intended to perfect existing redirect-based authentication and authorization protocols.  </p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#accept_applicability" id="accept_applicability">Applicability of Accept-* Headers</a>
</h1>
<p id="rfc.section.5.1.p.1">The purpose of the Accept-Auth <a href="#accept_auth" class="xref">Section 3</a>, Accept-Redirect <a href="#accept_redirect" class="xref">Section 2</a>, and Accept-Redirect-Auth <a href="#accept_redirect" class="xref">Section 2</a> request headers is to improve interoperability in heterogeneous environments with minimal or no changes to HTTP implementations.  </p>
<p id="rfc.section.5.1.p.2">For example, an application could set these request headers on requests without changes to the user-agent.  That's because setting arbitrary request headers is a common feature of HTTP user-agent implementations.  </p>
<p id="rfc.section.5.1.p.3">It is also common for HTTP server implementations to allow applications to inspect request headers produce 3xx redirect or 401 responses.  </p>
<p id="rfc.section.5.1.p.4">Thus one can modify client applications to set these headers, and server applications to check them and choose between 3xx redirect and 401 authenticate options, as well as between authentication schemes, based on the presence of those headers.  All without changes to HTTP implementations.  </p>
<p id="rfc.section.5.1.p.5">HTTP implementors will probably want to add support for these headers directly, but that isn't necessary in order to improve interoperability.  </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#redirect_applicability" id="redirect_applicability">Applicability of Redirect Auth Scheme</a>
</h1>
<p id="rfc.section.5.2.p.1">The new HTTP auth scheme, Redirect <a href="#redirect" class="xref">Section 4</a> also can be implemented without changes to HTTP implementations, but will be much more useful if implemented at least by user-agents.  </p>
<p id="rfc.section.5.2.p.2">In the short-term, the HTTP auth scheme, Redirect, is not applicable to any existing protocols or applications.  However, existing authentication and authorization systems, such as various Security Assertion Markup Language (SAML) profiles, as well as OpenID Connect (OIDC) and OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> mechanisms in general, such as JWT <a href="#RFC7519" class="xref">[RFC7519]</a>, can be adapted to use Redirect.  <a id="COMMENT_REFS_NEEDED0" class="info">[COMMENT_REFS_NEEDED0]<span class="info">NW: Need to add references for SAML.  Bibxml does not have any entries for OASIS specs!</span></a> </p>
<p id="rfc.section.5.2.p.3">Specifically, it is better to use headers for communication between relying parties and auth services than it is to use URI query parameters, as the latter imposes on application designeds.  Besides this, the Redirect auth scheme can greatly simplify adding support for, e.g., JWT, even for non-browser applications.  </p>
<p id="rfc.section.5.2.p.4">Thus the Redirect HTTP auth scheme is more likely to be useful in the future.  Note though that given user-agent support for Redirect, it's fairly easy to adapt SAML/OIDC/JWT identity providers to use it.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#mixing" id="mixing">Mixing Redirection and Authentication Requests</a>
</h1>
<p id="rfc.section.6.p.1">Making use of the new Accept-Auth, Accept-Redirect, and Accept-Redirect-Auth request headers will often require no changes to existing HTTP user-agents and servers.  This is because the application usually gets to set and inspect arbitrary headers.  On the server side it may be difficult for an application to add support for the Redirect authentication scheme without modifying the HTTP server.  Therefore it may be difficult for an application to issue a 401 Redirect, and it may have to use a 3xx redirect instead.  </p>
<p id="rfc.section.6.p.2">Therefore, user-agents MUST treat 3xx and 401 Redirect responses similarly, applying the same local policy in either case.  </p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#redirect_plus_auth" id="redirect_plus_auth">3xx Responses with WWW-Authenticate</a>
</h1>
<p id="rfc.section.6.1.p.1">If a server responds with a 3xx and includes not only a Location header but also a WWW-Authenticate header, then the redirect denotes intent to authenticate the user.  In this case, the user-agent SHALL consider the response to be either a redirect or a request to authenticate, at the user-agent's choice.  The HTTP method to use at the new Location SHALL be as specified for the status code used by the server.  </p>
<p id="rfc.section.6.1.p.2">Note that many user-agents will not understand that such responses represent an option to authenticate with some authentication scheme.  </p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#auth_plus_location" id="auth_plus_location">401 Responses with Location</a>
</h1>
<p id="rfc.section.6.2.p.1">If a server responds with a 401 and includes not just a WWW-Authenticate header but also a Location header, then the Location header's presence denotes the intent to authenticate the user either via the server's authentication scheme offerings, or redirection.  In this case, a user-agent conforming to this specification SHALL consider the response to be either a redirect or a request to authenticate, at the user-agent's choice, and SHOULD pick and execute one of those two options.  The user-agent SHOULD use the GET method at the new Location, with the expectation of eventually being redirected back to the original URI authority, at which point the user-agent, if it chooses to retry the original request, SHOULD use the original method.  </p>
<p id="rfc.section.6.2.p.2">Note that many user-agents will not understand that such responses represent an option to chase a redirection.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Auth-params for Selected Authentication Mechanisms</h1>
<p id="rfc.section.7.p.1">We specify here a few OPTIONAL parameters for existing HTTP authentication schemes that user-agents may use to convey relevant information to a server.  </p>
<p></p>

<ul>
<li>For the Basic <a href="#RFC2617" class="xref">[RFC2617]</a> authentication mechanism, user-agents MAY include a "realm" parameter.  </li>
<li>For the Digest <a href="#RFC2617" class="xref">[RFC2617]</a> authentication mechanism, user-agents MAY include "realm", "domain", "algorithm", and "qop-options" parameters.  </li>
<li>For the Negotiate <a href="#RFC4559" class="xref">[RFC4559]</a> authentication mechanism, user-agents MAY include a "mechs" auth-param whose value is a whitespace-separate list of Object IDentifiers (OIDs) in dotted number notation.  </li>
<li>For the Redirect authentication mechanism defined here, we define an auth-param, "auth-svcs" whose value is a list of whitespace-separated domainnames that the user-agent will follow redirections to.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Server-Side Selection of Authentication Schemes</h1>
<p id="rfc.section.8.p.1">Servers that support only one authentication scheme have no difficulty choosing which scheme to use.  For other servers, when the user-agent does not include the Accept-Auth header in its request, we have no advice.  When a server supports multiple authentication schemes and the user-agent does include the Accept-Auth header in its request, then the server SHOULD select at least one scheme for a 401 response's WWW-Authenticate header that the user-agent also supports, but the server MAY respond with a 3xx redirect response if the user-agent indicated support for redirects via the Accept-Redirect header or by advertising support for the Redirect HTTP authentication scheme.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.9.p.1">Ben Kaduk, Simo Sorce, Viktor Dukhovni, Bill Bernsen, Andrew Brown, and Geoffrey Thomas provided feedback and some review.  </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> IANA Considerations</h1>
<p id="rfc.section.10.p.1">IANA is requested to assign an expert to run the Expert Review for the registration of the Accept-Auth, Accept-Redirect, Accept-Redirect-Auth, and Authorization-Request headers in the message header registry.  </p>
<p id="rfc.section.10.p.2">Upon completion of IETF Review, IANA is directed to add the Redirect authentication scheme to the HTTP Authentication Scheme registry.  </p>
<p id="rfc.section.10.p.3">There is no registry for auth-params for HTTP authentication schemes, nor do we request the creation of such a registry.  The auth-params used here bear some relation to those of the authentication schemes they are used with, but they are essentially a distinct namespace.  Future additions of auth-params for use in the Accept-Auth header will have to update this document.  </p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.11.p.1">The Accept-Auth header is security-relevant as it helps negotiate authentication, which is a positive consideration.  Negative security considerations include multi-level negotiation issues <a href="#multi_level_nego" class="xref">Section 11.1</a>, as well as a privacy concern: that the Accept-Auth header may help fingerprint user-agents.  </p>
<p id="rfc.section.11.p.2">Privacy-conscious user-agents SHOULD have local policy about which authorities to use the new Accept-Auth, Accept-Redirect, and Accept-Redirect-Auth headers.  </p>
<p id="rfc.section.11.p.3">Also, the Authorization-Request and Authorization header preservation behavior allows attackers to convey malformed tokens to victim servers, allowing them to probe for parsing bugs.  However, this is already true for the URI itself, therefore this is not a new issue.  Note that Authorization headers are not to be preserved in all redirects, just those that backtrack in the redirect chain.  That means that there can be no confusion as to whether a given Authorization header was added by the user-agent or a redirecting origin: it will be either, but never both, and the relying party origins don't care which it is.  </p>
<p id="rfc.section.11.p.4">Adding support for channel / token binding to the Redirect HTTP auth scheme may well be possible and desirable.  This would consist of request headers set by the user-agent on redirected requests that would carry channel binding (CB) data for one or more CB types corresponding to the original origin (and/or previous hop).  </p>
<p id="rfc.section.11.p.5">One concern is that servers could cause user-agents to engage in authentication schemes they shouldn't want to -- that is a possibility regardless of whether the user-agent advertises support for an authentication scheme or not.  As usual, local policy is relevant.  For example, the "curl" user-agent by default will not chase redirections, and if enabled, it will by default not authenticate at any redirected authority (this can be further enabled).  User-agents SHOULD have local policy about which redirections they will accept, whether to authenticate to redirected authorities, and with what methods.  For example, a user-agent may be willing to use the Negotiate authentication scheme at some or any redirected authorities if it is happy to let Kerberos implementations, including Key Distribution Centers (KDCs), apply policy on the user-agent's behalf, but may not be willing to perform Basic, Digest, or SCRAM authentication to any redirected authorities not on a local whitelist.  </p>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#multi_level_nego" id="multi_level_nego">Multi-Level Negotiation</a>
</h1>
<p id="rfc.section.11.1.p.1">One important security consideration of the Accept-Auth header is that it may lead to multiple levels of negotiation (e.g., via the Negotiate <a href="#RFC4559" class="xref">[RFC4559]</a> authentication method).  Multi-level negotiations can fail to select to select a workable option, or may select a sub-optimal (e.g., less secure) option.  </p>
<p id="rfc.section.11.1.p.2">For example, a user-agent might be able to use Digest authentication and Negotiate with some GSS-API <a href="#RFC2743" class="xref">[RFC2743]</a> mechanism X, while the server might be able to use Digest and Negotiate with some GSS-API mechanism Y, and the server might prefer Y.  If the server knows only that the user-agent supports Digest and Negotiate, but not that the user-agent does not support GSS-API mechanism Y, then the server may send a challenge to use Negotiate and then the whole negotiation will fail.  </p>
<p id="rfc.section.11.1.p.3">In the above example the user-agent could recover by retrying without advertising Negotiate in its Accept-Auth header, but the user-agent is not likely to do this on account of that being too complex.  Neither the user-agent nor the server are likely to detect and recover from sub-optimal selections.  </p>
<p id="rfc.section.11.1.p.4">To avoid this failure more, user-agents SHOULD use auth-params to convey information that the server might need to make an appropriate.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2617">[RFC2617]</b></td>
<td class="top">
<a>Franks, J.</a>, <a>Hallam-Baker, P.</a>, <a>Hostetler, J.</a>, <a>Lawrence, S.</a>, <a>Leach, P.</a>, <a>Luotonen, A.</a> and <a>L. Stewart</a>, "<a href="https://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>", RFC 2617, DOI 10.17487/RFC2617, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4559">[RFC4559]</b></td>
<td class="top">
<a>Jaganathan, K.</a>, <a>Zhu, L.</a> and <a>J. Brezak</a>, "<a href="https://tools.ietf.org/html/rfc4559">SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</a>", RFC 4559, DOI 10.17487/RFC4559, June 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7235">[RFC7235]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>", RFC 7235, DOI 10.17487/RFC7235, June 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2743">[RFC2743]</b></td>
<td class="top">
<a>Linn, J.</a>, "<a href="https://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>", RFC 2743, DOI 10.17487/RFC2743, January 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4120">[RFC4120]</b></td>
<td class="top">
<a>Neuman, C.</a>, <a>Yu, T.</a>, <a>Hartman, S.</a> and <a>K. Raeburn</a>, "<a href="https://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>", RFC 4120, DOI 10.17487/RFC4120, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4121">[RFC4121]</b></td>
<td class="top">
<a>Zhu, L.</a>, <a>Jaganathan, K.</a> and <a>S. Hartman</a>, "<a href="https://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>", RFC 4121, DOI 10.17487/RFC4121, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7519">[RFC7519]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)</a>", RFC 7519, DOI 10.17487/RFC7519, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nico Williams</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Williams</span>
	  </span>
	</span>
	<span class="org vcardline">Cryptonector, LLC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Austin</span>,  
		<span class="region">TX</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com">nico@cryptonector.com</a></span>

  </address>
</div>

</body>
</html>
